// FileTransferClient.java
package myrmi;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;

public class FileTransferClient {
    private static final int CHUNK_SIZE = 1024 * 1024; // 1MB chunk size
    private MetadataService metadataService;
    private Registry registry;
    private ExecutorService executorService; // For background transfers

    public FileTransferClient(String host, int port) throws Exception {
        this.registry = LocateRegistry.getRegistry(host, port);
        this.metadataService = (MetadataService) registry.lookup("MetadataService");
        this.executorService = Executors.newCachedThreadPool(); // Flexible thread pool
        System.out.println("Connected to Metadata Service.");
    }

    // --- Public Methods for UI to Call ---

    public List<String> listAvailableFiles() throws Exception {
        return metadataService.listAllFiles();
    }

    public void uploadFile(File file, Consumer<Integer> progressCallback, Runnable onComplete, Consumer<Exception> onError) {
        executorService.submit(() -> {
            try {
                _uploadFile(file, progressCallback);
                metadataService.registerFile(file.getName(), file.length(), currentChunkLocations); // Register after full upload
                System.out.println("File '" + file.getName() + "' uploaded successfully.");
                if (onComplete != null) {
                    onComplete.run();
                }
            } catch (Exception e) {
                System.err.println("Error uploading file: " + e.getMessage());
                e.printStackTrace();
                if (onError != null) {
                    onError.accept(e);
                }
            }
        });
    }

    public void downloadFile(String fileName, String outputDirectory, Consumer<Integer> progressCallback, Runnable onComplete, Consumer<Exception> onError) {
        executorService.submit(() -> {
            try {
                _downloadFile(fileName, outputDirectory, progressCallback);
                System.out.println("File '" + fileName + "' downloaded successfully.");
                if (onComplete != null) {
                    onComplete.run();
                }
            } catch (Exception e) {
                System.err.println("Error downloading file: " + e.getMessage());
                e.printStackTrace();
                if (onError != null) {
                    onError.accept(e);
                }
            }
        });
    }

    // --- Private Helper Methods for RMI Logic ---

    // Using a class-level map to store chunk locations during a single upload
    // For concurrent uploads, this needs to be passed into the _uploadFile method or handled differently
    // For simplicity in a single-file UI context, this approach is fine.
    private Map<Integer, String> currentChunkLocations = new HashMap<>(); // Temporary storage for current upload

    private void _uploadFile(File file, Consumer<Integer> progressCallback) throws Exception {
        currentChunkLocations.clear(); // Clear for new upload
        long fileSize = file.length();
        int chunkIndex = 0;
        long totalBytesRead = 0;

        try (FileInputStream fis = new FileInputStream(file)) {
            byte[] buffer = new byte[CHUNK_SIZE];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                byte[] chunkData = new byte[bytesRead];
                System.arraycopy(buffer, 0, chunkData, 0, bytesRead);

                String storageServerId = metadataService.getAvailableStorageServer();
                StorageService storageService = (StorageService) registry.lookup(storageServerId);

                String chunkId = file.getName() + "_chunk_" + chunkIndex;
                storageService.uploadChunk(chunkId, chunkData);
                currentChunkLocations.put(chunkIndex, storageServerId); // Store which server has this chunk
                
                totalBytesRead += bytesRead;
                int progress = (int) ((totalBytesRead * 100) / fileSize);
                if (progressCallback != null) {
                    progressCallback.accept(progress);
                }
                chunkIndex++;
            }
        }
        // Registration moved to uploadFile public method to ensure all chunks are done before registering.
    }

    private void _downloadFile(String fileName, String outputDirectory, Consumer<Integer> progressCallback) throws Exception {
        Map<Integer, String> chunkLocations = metadataService.getFileMetadata(fileName);
        if (chunkLocations == null || chunkLocations.isEmpty()) {
            throw new Exception("File '" + fileName + "' not found or no chunks registered.");
        }

        File outputFile = new File(outputDirectory, fileName);
        Path outputPath = outputFile.toPath();
        if (Files.exists(outputPath)) {
            Files.delete(outputPath); // Ensure clean download by deleting existing file
        }
        Files.createDirectories(outputPath.getParent()); // Ensure output directory exists

        // Calculate total file size for accurate progress
        long totalFileSize = 0;
        for (Integer chunkIndex : chunkLocations.keySet()) {
            // This is a simplification; ideally, metadata should store chunk sizes if not fixed
            // For fixed chunk size, estimate total size by (num_chunks-1)*CHUNK_SIZE + last_chunk_size
            // For now, let's assume CHUNK_SIZE for all except maybe the last, or better, get size from metadata if available.
            // For simplicity and matching current metadata, we'll just track bytes downloaded.
            // A more robust system would store chunk sizes in metadata or send file size explicitly.
            // For now, we'll update progress based on the number of chunks downloaded.
        }

        long bytesDownloaded = 0;
        List<Integer> sortedChunkIndexes = new ArrayList<>(chunkLocations.keySet());
        sortedChunkIndexes.sort(null); // Sort to ensure correct order

        try (FileOutputStream fos = new FileOutputStream(outputFile)) {
            for (Integer chunkIndex : sortedChunkIndexes) {
                String storageServerId = chunkLocations.get(chunkIndex);
                StorageService storageService = (StorageService) registry.lookup(storageServerId);

                String chunkId = fileName + "_chunk_" + chunkIndex;
                byte[] chunkData = storageService.downloadChunk(chunkId);
                fos.write(chunkData);
                
                bytesDownloaded += chunkData.length;
                // Calculate progress based on number of chunks or total bytes if available
                int progress = (int) ((double) (chunkIndex + 1) / sortedChunkIndexes.size() * 100);
                if (progressCallback != null) {
                    progressCallback.accept(progress);
                }
            }
        }
    }
    
    // Remember to shut down the executor service when the application exits
    public void shutdown() {
        executorService.shutdown();
    }
}